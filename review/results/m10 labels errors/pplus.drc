# frozen_string_literal: true

################################################################################################
# Copyright 2023 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

#=======================================================================================================================
#--------------------------------------------- GF 0.18um MCU DRC RULE DECK ---------------------------------------------
#=======================================================================================================================
require 'time'
require 'logger'
require 'etc'

exec_start_time = Time.now

logger = Logger.new($stdout)

logger.formatter = proc do |_severity, datetime, _progname, msg|
  "#{datetime}: Memory Usage (" + `pmap #{Process.pid} | tail -1`[10, 40].strip + ") : #{msg}
"
end

#================================================
#----------------- FILE SETUP -------------------
#================================================
logger.info("Starting running GF180MCU Klayout DRC runset on #{$input}")
logger.info("Ruby Version for klayout: #{RUBY_VERSION}")

if $input
  if $topcell
    source($input, $topcell)
  else
    source($input)
  end
end

logger.info('Loading database to memory is complete.')

if $report
  logger.info("GF180MCU Klayout DRC runset output at: #{$report}")
  report('DRC Run Report at', $report)
else
  layout_dir = Pathname.new(RBA::CellView.active.filename).parent.realpath
  report_path = layout_dir.join('gf180_drc.lyrdb').to_s
  logger.info("GF180MCU Klayout DRC runset output at default location: #{report_path}")
  report('DRC Run Report at', report_path)
end

#================================================
#------------------ SWITCHES --------------------
#================================================
logger.info('Evaluate switches.')

def bool_check?(obj)
  obj.to_s.downcase == 'true'
end

TABLE_NAME = $table_name || 'main'

logger.info("table_name selected  #{TABLE_NAME}")

# connectivity rules
CONNECTIVITY_EN = bool_check?($conn_drc)

conn_tables = %w[dnwell dnwell_split nwell nwell_split lvpwell
                 lvpwell_split nat nat_split ldnmos ldnmos_split ldpmos ldpmos_split main]

CONNECTIVITY_RULES = if conn_tables.include?(TABLE_NAME) && CONNECTIVITY_EN
                       true
                     else
                       false
                     end

logger.info("CONNECTIVITY_RULES enabled: #{CONNECTIVITY_RULES}")

# split deep rules
SPLIT_DEEP = bool_check?($split_deep)

# WEDGE
WEDGE = bool_check?($wedge)

logger.info("Wedge enabled: #{WEDGE}")

# BALL
BALL = bool_check?($ball)

logger.info("Ball enabled: #{BALL}")

# GOLD
GOLD = bool_check?($gold)

logger.info("Gold enabled: #{GOLD}")

# MIM
MIM_OPTION = $mim_option || 'B'

logger.info("MIM Option selected: #{MIM_OPTION}")

# OFFGRID
OFFGRID = $offgrid != 'false'

logger.info("Offgrid enabled:  #{OFFGRID}")

# threads
if $thr
  threads($thr)
else
  thr ||= Etc.nprocessors
  threads(thr)
end

logger.info("Number of threads to use #{$thr}")

#=== PRINT DETAILS ===

verbose(bool_check?($verbose))

logger.info("Verbose mode: #{$verbose}")

# === TILING MODE ===
case $run_mode
## Tiling mode is for testing purpose only [Not used in run_drc.py]
when 'tiling'
  tiles(500.um)
  tile_borders(50.um)
  logger.info('Tiling  mode is enabled.')

when 'deep'
  #=== HIER MODE ===
  deep
  logger.info("deep  mode is enabled for #{TABLE_NAME} table")
else
  #=== FLAT MODE ===
  flat
  logger.info("flat  mode is enabled for #{TABLE_NAME} table")
end

# METAL_TOP
METAL_TOP = $metal_top || '9K'

logger.info("METAL_TOP Selected is #{METAL_TOP}")

# METAL_LEVEL
METAL_LEVEL = $metal_level || '5LM'

logger.info("METAL_STACK Selected is #{METAL_LEVEL}")

# FEOL
FEOL = bool_check?($feol)

logger.info("FEOL enabled: #{FEOL}")

# BEOL
BEOL = bool_check?($beol)

logger.info("BEOL enabled: #{BEOL}")

## SLOW_VIA
SLOW_VIA = bool_check?($slow_via)

logger.info("SLOW_VIA enabled: #{SLOW_VIA}")

#================================================
#------------- LAYERS DEFINITIONS ---------------
#================================================

# %include layers_def.drc

#=====================================================
#------------- BASE LAYERS DERIVATIONS ---------------
#=====================================================

dnwell_n        = dnwell.not(lvpwell)
dnwell_p        = dnwell.and(lvpwell)

all_nwell       = dnwell_n.join(nwell)

ncomp           = comp.and(nplus)
pcomp           = comp.and(pplus)
tgate           = poly2.and(comp).not(res_mk)

nactive         = ncomp.not(all_nwell)
ngate           = nactive.and(tgate)
nsd             = nactive.interacting(ngate).not(ngate).not(res_mk)
ptap            = pcomp.not(all_nwell).not(res_mk)

pactive         = pcomp.and(all_nwell)
pgate           = pactive.and(tgate)
psd             = pactive.interacting(pgate).not(pgate).not(res_mk)
ntap            = ncomp.and(all_nwell).not(res_mk)

ngate_dn        = ngate.and(dnwell_p)
ptap_dn         = ptap.and(dnwell_p).outside(well_diode_mk)

pgate_dn        = pgate.and(dnwell_n)
ntap_dn         = ntap.and(dnwell_n)

psd_dn          = pcomp.and(dnwell_n).interacting(pgate_dn).not(pgate_dn).not(res_mk)
nsd_dn          = ncomp.and(dnwell_p).interacting(ngate_dn).not(ngate_dn).not(res_mk)

natcomp        	= nat.and(comp)

# Gate
nom_gate = tgate.not(dualgate)
thick_gate = tgate.and(dualgate)

ngate_56v = ngate.and(dualgate)
pgate_56v = pgate.and(dualgate)

ngate_5v = ngate_56v.and(v5_xtor)
pgate_5v = pgate_56v.and(v5_xtor)

ngate_6v = ngate_56v.not(v5_xtor)
pgate_6v = pgate_56v.not(v5_xtor)

# DNWELL
dnwell_3p3v = dnwell.not_interacting(v5_xtor).not_interacting(dualgate)
dnwell_56v = dnwell.overlapping(dualgate)

# LVPWELL
lvpwell_dn = lvpwell.interacting(dnwell)
lvpwell_out = lvpwell.not_interacting(dnwell)

lvpwell_dn3p3v = lvpwell.and(dnwell_3p3v)
lvpwell_dn56v = lvpwell.and(dnwell_56v)

# NWELL
nwell_dn = nwell.interacting(dnwell)
nwell_n_dn = nwell.not_interacting(dnwell)

#================================================
#------------- LAYERS CONNECTIONS ---------------
#================================================

if CONNECTIVITY_RULES
  logger.info('Construct connectivity for the design.')

  connect(dnwell, ncomp)
  connect(lvpwell_out, pcomp)
  connect(lvpwell_dn, pcomp)
  connect(nwell, ncomp)
  connect(mvsd, ncomp)
  connect(mvpsd, pcomp)

  if contact_tables.include?(TABLE_NAME)
    connect(ncomp,  contact)
    connect(pcomp,  contact)
    connect(natcomp, contact)
    connect(contact, metal1)
  end

  if via1_tables.include?(TABLE_NAME)
    connect(metal1,  via1)
    connect(via1,    metal2)
  end

  case METAL_LEVEL
  when '3LM', '4LM', '5LM', '6LM'
    if via2_tables.include?(TABLE_NAME)
      connect(metal2,  via2)
      connect(via2,    metal3)
    end
  end
  case METAL_LEVEL
  when '4LM', '5LM', '6LM'
    connect(metal3,  via3)
    connect(via3,    metal4)
  end
  case METAL_LEVEL
  when '5LM', '6LM'
    connect(metal4,  via4)
    connect(via4,    metal5)
  end
  case METAL_LEVEL
  when '6LM'
    connect(metal5,  via5)
    connect(via5,    metaltop)
  end
end

#================================================
#------------ PRE-DEFINED FUNCTIONS -------------
#================================================

def unconn_errors_check(net1, net2, unconnected_errors)
  if !net1 || !net2
    logger.error("Connectivity check encountered 2 nets that doesn't exist. Potential issue in klayout...")
  elsif net1.circuit != net2.circuit || net1.cluster_id != net2.cluster_id
    # unconnected
    unconnected_errors.data.insert(ep)
  end
  unconnected_errors
end

def get_nets(_data, layer1, layer2, edge_pairs)
  net1 = l2n_data.probe_net(layer1.data, edge_pairs.first.p1)
  net2 = l2n_data.probe_net(layer2.data, edge_pairs.second.p1)
  [net1, net2]
end

def conn_space_viol(layer, conn_val, mode)
  connected_output = layer.space(conn_val.um, mode).polygons(0.001.um)
  singularity_errors = layer.space(0.001.um, mode).polygons(0.001.um)
  [connected_output, singularity_errors]
end

def conn_space_check(layer, not_conn_val, mode)
  unconnected_errors_unfiltered = layer.space(not_conn_val.um, mode)
  connected_output, singularity_errors = conn_space_viol(layer, conn_val, mode)
  # Filter out the errors arising from the same net
  unconnected_errors = DRC::DRCLayer.new(self, RBA::EdgePairs.new)
  unconnected_errors_unfiltered.data.each do |ep|
    net1, net2 = get_nets(l2n_data, layer, layer, ep)
    unconnected_errors = unconn_errors_check(net1, net2, unconnected_errors)
  end
  unconnected_output = unconnected_errors.polygons.join(singularity_errors)
  [connected_output, unconnected_output]
end

def conn_space_nets(layer, conn_val, not_conn_val, mode)
  nets = layer.nets
  connected_output = nets.space(conn_val.um, mode, props_eq).polygons(0.001.um)
  singularity_errors = nets.space(0.001.um, mode).polygons(0.001.um)
  unconnected_output = nets.space(not_conn_val.um, mode, props_ne).polygons(0.001.um).join(singularity_errors)
  [connected_output, unconnected_output]
end

def conn_space(layer, conn_val, not_conn_val, mode)
  if layer.respond_to?(:nets) # KLayout version (>=0.28.4) which supports "nets"
    connected_output, unconnected_output = conn_space_nets(layer, conn_val, not_conn_val, mode)
  else
    raise 'ERROR : Wrong connectivity implementation' if conn_val > not_conn_val

    connected_output, unconnected_output = conn_space_check(layer, not_conn_val, mode)
  end
  [connected_output, unconnected_output]
end

def sep_viol_nets(layer1, layer2, conn_val, not_conn_val, mode)
  connected_output   = layer1.nets.separation(layer2.nets, conn_val.um,     mode, props_eq).polygons(0.001.um)
  unconnected_output = layer1.nets.separation(layer2.nets, not_conn_val.um, mode, props_ne).polygons(0.001.um)
  [connected_output, unconnected_output]
end

def unconn_separation_check(layer1, layer2, not_conn_val, mode)
  unconnected_errors_unfiltered = layer1.separation(layer2, not_conn_val.um, mode)
  # Filter out the errors arising from the same net
  unconnected_errors = DRC::DRCLayer.new(self, RBA::EdgePairs.new)
  unconnected_errors_unfiltered.data.each do |ep|
    net1, net2 = get_nets(l2n_data, layer1, layer2, ep)
    unconnected_errors = unconn_errors(net1, net2, unconnected_errors)
  end
  unconnected_errors
end

def conn_separation(layer1, layer2, conn_val, not_conn_val, mode)
  if layer1.respond_to?(:nets) # KLayout version (>=0.28.4) which supports "nets"
    connected_output, unconnected_output = sep_viol_nets(layer1, layer2, conn_val, not_conn_val, mode)
  else
    raise 'ERROR : Wrong connectivity implementation' if conn_val > not_conn_val

    connected_output = layer1.separation(layer2, conn_val.um, mode).polygons(0.001.um)
    unconnected_errors = unconn_separation_check(layer1, layer2, not_conn_val, mode)
    unconnected_output = unconnected_errors.polygons(0.001.um)
  end
  [connected_output, unconnected_output]
end

def size_overunder_in_layers(large_layer, size_layer, size_value)
  out_layer = DRC::DRCLayer.new(self, RBA::Region.new)
  large_layer.data.each do |ep|
    curr_large_layer = DRC::DRCLayer.new(self, RBA::Region.new(ep))
    curr_large_layer = curr_large_layer.and(size_layer)
    curr_large_layer = curr_large_layer.sized(size_value, 'square_limit').merged.sized(-size_value, 'square_limit')
    out_layer.data.insert(curr_large_layer.data)
  end
  out_layer
end

# === IMPLICIT EXTRACTION ===
if CONNECTIVITY_RULES
  logger.info('Connectivity rules enabled, Netlist object will be generated.')
  netlist
end

# === LAYOUT EXTENT ===
CHIP = extent.sized(0.0)
logger.info("Total area of the design is #{CHIP.area} um^2.")

#================================================
#----------------- MAIN RUNSET ------------------
#================================================

logger.info('Starting GF180MCU DRC rules.')
logger.info('Running all FEOL rules') if FEOL

logger.info('Running all BEOL rules') if BEOL
# frozen_string_literal: true

################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL

  #================================================
  #---------------------PPLUS----------------------
  #================================================

  logger.info('Starting PPLUS derivations')

  nplus_edges = nplus.edges
  pplus_edges = pplus.edges
  ncomp_edges = ncomp.edges
  pcomp_butted = pcomp.interacting(ncomp)
  pplus_butted_edges = pplus.edges.and(ncomp.edges)
  nwell_n_dn_sized_out = nwell_n_dn.sized(0.429.um)
  nwell_n_dn_sized_in  = nwell_n_dn.sized(-0.429.um)
  lvpwell_dn_sized_out = lvpwell_dn.sized(0.429.um)
  lvpwell_dn_sized_in  = lvpwell_dn.sized(-0.429.um)

  # Rule PP.1: min. pplus width is 0.4µm
  logger.info('Executing rule PP.1')
  pp1_l1 = pplus.width(0.4.um, euclidian)
  pp1_l1.output('PP.1', 'PP.1 : min. pplus width : 0.4µm')
  pp1_l1.forget

  # Rule PP.2: min. pplus spacing is 0.4µm
  logger.info('Executing rule PP.2')
  pp2_l1 = pplus.space(0.4.um, euclidian)
  pp2_l1.output('PP.2', 'PP.2 : min. pplus spacing : 0.4µm')
  pp2_l1.forget

  # Rule PP.3a: Space to NCOMP for NCOMP (1) inside LVPWELL (2) outside NWELL and DNWELL. is 0.16µm
  logger.info('Executing rule PP.3a')
  pp3_pplus = pplus.not_interacting(pcomp_butted)
  pp3a_ncomp = ncomp.and(lvpwell).join(ncomp.not(nwell_n_dn))
  pp3a_l1 = pp3_pplus.separation(pp3a_ncomp, 0.16.um, euclidian)
  pp3a_l1.output('PP.3a',
                 'PP.3a : Space to NCOMP for NCOMP (1) inside LVPWELL (2) outside NWELL and DNWELL: 0.16µm')
  pp3a_l1.forget
  pp3a_ncomp.forget

  # Rule PP.3bi: Space to NCOMP: For Inside DNWELL. (i) NCOMP space to LVPWELL >= 0.43um is 0.08µm.
  logger.info('Executing rule PP.3bi')
  pp_3bi_ncomp = ncomp.not(lvpwell_dn_sized_out)
  pp3bi_l1 = pp3_pplus.and(dnwell).separation(pp_3bi_ncomp, 0.08.um, euclidian)
  pp3bi_l1.output('PP.3bi',
                  'PP.3bi : Space to NCOMP: For Inside DNWELL. (i) NCOMP space to LVPWELL >= 0.43um: 0.08µm')
  pp3bi_l1.forget
  pp_3bi_ncomp.forget

  # Rule PP.3bii: Space to NCOMP: For Inside DNWELL.
  ## (ii) NCOMP space to LVPWELL < 0.43um. is 0.16µm
  logger.info('Executing rule PP.3bii')
  pp_3bii_ncomp = ncomp.and(lvpwell_dn_sized_out)
  pp3bii_l1 = pp3_pplus.and(dnwell).separation(pp_3bii_ncomp, 0.16.um, euclidian)
  pp3bii_l1.output('PP.3bii', "PP.3bii : Space to NCOMP: For Inside DNWELL.
                      (ii) NCOMP space to LVPWELL < 0.43um. : 0.16µm")
  pp3bii_l1.forget
  pp_3bii_ncomp.forget

  # Rule PP.3ci: Space to NCOMP: For Outside DNWELL, inside Nwell:
  ## (i) NWELL Overlap of NCOMP >= 0.43um is 0.08µm.
  logger.info('Executing rule PP.3ci')
  pp_3ci_ncomp = ncomp.and(nwell_n_dn_sized_in)
  pp3ci_l1 = pp3_pplus.and(nwell_n_dn).separation(pp_3ci_ncomp, 0.08.um, euclidian)
  pp3ci_l1.output('PP.3ci', "PP.3ci : Space to NCOMP: For Outside DNWELL, inside Nwell:
                    (i) NWELL Overlap of NCOMP >= 0.43um: 0.08µm")
  pp3ci_l1.forget
  pp_3ci_ncomp.forget

  # Rule PP.3cii: Space to NCOMP: For Outside DNWELL, inside Nwell:
  ## (ii) NWELL Overlap of NCOMP 0.43um. is 0.16µm
  logger.info('Executing rule PP.3cii')
  pp_3cii_ncomp = ncomp.and(nwell_n_dn.not(nwell_n_dn_sized_in))
  pp3cii_l1 = pp3_pplus.and(nwell_n_dn).separation(pp_3cii_ncomp, 0.16.um, euclidian)
  pp3cii_l1.output('PP.3cii', "PP.3cii : Space to NCOMP: For Outside DNWELL, inside Nwell:
                     (ii) NWELL Overlap of NCOMP 0.43um. : 0.16µm")
  pp3cii_l1.forget
  pp_3cii_ncomp.forget

  # Rule PP.3d: Min/max space to a butted NCOMP is 0um.
  logger.info('Executing rule PP.3d')
  pp3d_l1 = pcomp.and(ncomp)
  pp3d_l1.output('PP.3d', 'PP.3d : Min/max space to a butted NCOMP: 0um')
  pp3d_l1.forget

  # Rule PP.3e: Space to NCOMP edge adjacent to a butting edge is 0um.
  logger.info('Executing rule PP.3e')
  pp3e_l1 = pplus.and(ncomp)
  pp3e_l1.output('PP.3e', 'PP.3e : Space to NCOMP edge adjacent to a butting edge: 0um')
  pp3e_l1.forget

  # Rule PP.4a: Space related to N-channel gate at a butting edge parallel to gate. is 0.32µm
  logger.info('Executing rule PP.4a')
  pp4a_l1 = pplus_edges.and(ncomp_edges).separation(ngate.edges, 0.32.um, projection)
  pp4a_l1.output('PP.4a', 'PP.4a : Space related to N-channel gate at a butting edge parallel to gate. : 0.32µm')
  pp4a_l1.forget

  # Rule PP.4b: Within 0.32um of channel, space to N-channel gate
  ## extension perpendicular to the direction of Poly2.
  logger.info('Executing rule PP.4b')
  pp_4b_poly = poly2.edges.interacting(ngate.edges.not(ncomp_edges)).centers(0, 0.99).and(ngate.sized(0.32.um))
  pp4b_l1 = pplus.interacting(pplus_edges.separation(pp_4b_poly, 0.22.um, projection).polygons(0.001.um))
  pp4b_l1.output('PP.4b', "PP.4b : Within 0.32um of channel, space to N-channel gate
                    extension perpendicular to the direction of Poly2.")
  pp4b_l1.forget
  pp_4b_poly.forget

  # Rule PP.5a: Overlap of P-channel gate. is 0.23µm
  logger.info('Executing rule PP.5a')
  pp5a_l1 = pplus.enclosing(pgate, 0.23.um, euclidian).polygons(0.001.um)
  pp5a_l2 = pgate.not_outside(pplus).not(pplus)
  pp5a_l  = pp5a_l1.join(pp5a_l2)
  pp5a_l.output('PP.5a', 'PP.5a : Overlap of P-channel gate. : 0.23µm')
  pp5a_l1.forget
  pp5a_l2.forget
  pp5a_l.forget

  # Rule PP.5b: Extension beyond COMP for COMP
  ## (1) Inside NWELL (2) outside LVPWELL but inside DNWELL. is 0.16µm
  logger.info('Executing rule PP.5b')
  pp5b_pplus_slct = pplus.edges.not(pplus_butted_edges)
  pp5b_pplus = pp5b_pplus_slct.and(nwell).join(pp5b_pplus_slct.not(lvpwell).and(dnwell))
  pp5b_l1 = pcomp.edges.enclosed(pp5b_pplus, 0.16.um, projection)
  pp5b_l1.output('PP.5b', 'PP.5b : Extension beyond COMP for COMP
                 (1) Inside NWELL (2) outside LVPWELL but inside DNWELL. : 0.16µm')
  pp5b_l1.forget
  pp5b_pplus.forget
  pp5b_pplus_slct.forget

  # Rule PP.5ci: Extension beyond COMP: For Inside DNWELL, inside LVPWELL:
  ##  (i) For LVPWELL overlap of Pplus >= 0.43um for LVPWELL tap. is 0.02µm
  logger.info('Executing rule PP.5ci')
  pp_5ci_background = pplus.not_outside(lvpwell).inside(dnwell).edges.not(nplus_edges)
  pp_5ci_foreground = pcomp.not_outside(lvpwell).inside(dnwell).edges.not(nplus_edges).inside_part(lvpwell_dn_sized_in)
  pp5ci_l1 = pp_5ci_background.enclosing(pp_5ci_foreground, 0.02.um, euclidian)
  pp5ci_l1.output('PP.5ci', "PP.5ci : Extension beyond COMP: For Inside DNWELL, inside LVPWELL:
                    (i) For LVPWELL overlap of Pplus >= 0.43um for LVPWELL tap. : 0.02µm")
  pp5ci_l1.forget
  pp_5ci_background.forget
  pp_5ci_foreground.forget

  # Rule PP.5cii: Extension beyond COMP: For Inside DNWELL, inside LVPWELL:
  ## (ii) For LVPWELL overlap of Pplus < 0.43um for the LVPWELL tap. is 0.16µm
  logger.info('Executing rule PP.5cii')
  pp_5cii_background = pplus.not_outside(lvpwell).inside(dnwell).edges
  pp_5cii_extend = lvpwell_dn.not(lvpwell_dn_sized_in)
  pp_5cii_foreground = pcomp.not_outside(lvpwell).inside(dnwell).edges.not(nplus_edges).and(pp_5cii_extend)
  pp5cii_l1 = pp_5cii_background.enclosing(pp_5cii_foreground, 0.16.um, projection)
  pp5cii_l1.output('PP.5cii', "PP.5cii : Extension beyond COMP: For Inside DNWELL, inside LVPWELL:
                     (ii) For LVPWELL overlap of Pplus < 0.43um for the LVPWELL tap. : 0.16µm")
  pp5cii_l1.forget
  pp_5cii_background.forget
  pp_5cii_extend.forget
  pp_5cii_foreground.forget
  lvpwell_dn_sized_in.forget

  # Rule PP.5di: Extension beyond COMP: For Outside DNWELL
  ## (i) For Pplus to NWELL space >= 0.43um for Pfield or LVPWELL tap. is 0.02µm
  logger.info('Executing rule PP.5di')
  pp_5d_background = pplus.outside(dnwell).edges
  pp_5d_pcomp = pcomp.outside(dnwell).edges
  pp_5di_foreground = pp_5d_pcomp.not(nplus_edges).not(nwell_n_dn_sized_out)
  pp5di_l1 = pp_5d_background.enclosing(pp_5di_foreground, 0.02.um, projection)
  pp5di_l1.output('PP.5di', "PP.5di : Extension beyond COMP: For Outside DNWELL
                    (i) For Pplus to NWELL space >= 0.43um for Pfield or LVPWELL tap. : 0.02µm")
  pp5di_l1.forget
  pp_5di_foreground.forget

  # Rule PP.5dii: Extension beyond COMP: For Outside DNWELL
  ## (ii) For Pplus to NWELL space < 0.43um for Pfield or LVPWELL tap. is 0.16µm
  logger.info('Executing rule PP.5dii')
  pp_5dii_foreground = pp_5d_pcomp.not(nplus_edges).and(nwell_n_dn_sized_out)
  pp5dii_l1 = pp_5d_background.enclosing(pp_5dii_foreground, 0.16.um, projection)
  pp5dii_l1.output('PP.5dii', "PP.5dii : Extension beyond COMP: For Outside DNWELL
                     (ii) For Pplus to NWELL space < 0.43um for Pfield or LVPWELL tap. : 0.16µm")
  pp5dii_l1.forget
  pp_5d_background.forget
  pp_5dii_foreground.forget
  nplus_edges.forget
  pp_5d_pcomp.forget
  nwell_n_dn_sized_out.forget

  # Rule PP.6: Overlap with PCOMP butted to NCOMP. is 0.22µm
  logger.info('Executing rule PP.6')
  pp6_l1 = comp.interacting(pplus).enclosing(ncomp.interacting(pplus), 0.22.um, projection).polygons
  pp6_l1.output('PP.6', 'PP.6 : Overlap with PCOMP butted to NCOMP. : 0.22µm')
  pp6_l1.forget

  # Rule PP.7: Space to unrelated unsalicided Poly2. is 0.18µm
  logger.info('Executing rule PP.7')
  pp7_l1 = pplus.separation(poly2.and(sab), 0.18.um, euclidian)
  pp7_l1.output('PP.7', 'PP.7 : Space to unrelated unsalicided Poly2. : 0.18µm')
  pp7_l1.forget

  # Rule PP.8a: Minimum Pplus area (um2). is 0.35µm²
  logger.info('Executing rule PP.8a')
  pp8a_l1 = pplus.with_area(nil, 0.35.um)
  pp8a_l1.output('PP.8a', 'PP.8a : Minimum Pplus area (um2). : 0.35µm²')
  pp8a_l1.forget

  # Rule PP.8b: Minimum area enclosed by Pplus (um2). is 0.35µm²
  logger.info('Executing rule PP.8b')
  pp8b_l1 = pplus.holes.with_area(nil, 0.35.um)
  pp8b_l1.output('PP.8b', 'PP.8b : Minimum area enclosed by Pplus (um2). : 0.35µm²')
  pp8b_l1.forget

  # Rule PP.9: Overlap of unsalicided Poly2. is 0.18µm
  logger.info('Executing rule PP.9')
  pp9_l1 = pplus.enclosing(poly2.not_interacting(resistor).and(sab), 0.18.um, euclidian).polygons(0.001.um)
  pp9_l2 = poly2.not_interacting(resistor).and(sab).not_outside(pplus).not(pplus)
  pp9_l  = pp9_l1.join(pp9_l2)
  pp9_l.output('PP.9', 'PP.9 : Overlap of unsalicided Poly2. : 0.18µm')
  pp9_l1.forget
  pp9_l2.forget
  pp9_l.forget

  # Rule PP.10: Overlap of unsalicided COMP. is 0.18µm
  logger.info('Executing rule PP.10')
  pp10_l1 = pplus.enclosing(comp.and(sab), 0.18.um, euclidian)
  pp10_l1.output('PP.10', 'PP.10 : Overlap of unsalicided COMP. : 0.18µm')
  pp10_l1.forget

  # Rule PP.11: Butting Pplus and NCOMP is forbidden within 0.43um of Nwell edge
  ## (for outside DNWELL) and of LVPWELL edge (for inside DNWELL case).
  logger.info('Executing rule PP.11')
  pp_11_nwell_exclusion_area = nwell_n_dn.not(nwell_n_dn_sized_in)
  pp_11_lvpwell_exclude_area = lvpwell_dn_sized_out.not(lvpwell_dn)
  pp11_l1 = pplus_butted_edges.and(pp_11_nwell_exclusion_area)
  pp11_l2 = pplus_butted_edges.and(pp_11_lvpwell_exclude_area)
  pp11_l = pp11_l1.join(pp11_l2)
  pp11_l.output('PP.11', "PP.11 : Butting Pplus and NCOMP is forbidden within 0.43um of Nwell edge
                    (for outside DNWELL) and of LVPWELL edge (for inside DNWELL case).")
  pp11_l.forget
  pp11_l1.forget
  pp11_l2.forget
  pp_11_nwell_exclusion_area.forget
  pp_11_lvpwell_exclude_area.forget
  pplus_butted_edges.forget
  nwell_n_dn_sized_in.forget
  lvpwell_dn_sized_out.forget

  # Rule PP.12: Overlap with N-channel Poly2 gate extension is forbidden
  ##  within 0.32um of N-channel gate.
  logger.info('Executing rule PP.12')
  pp12_l1 = pplus.interacting(pplus_edges.separation(ngate.edges.and(ncomp_edges), 0.32.um,
                                                     euclidian).polygons(0.001.um))
  pp12_l1.output('PP.12', "PP.12 : Overlap with N-channel Poly2 gate extension is forbidden
                    within 0.32um of N-channel gate.")
  pp12_l1.forget
  pplus_edges.forget
  ncomp_edges.forget
end
# frozen_string_literal: true

################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

exec_end_time = Time.now
run_time = exec_end_time - exec_start_time
logger.info("#{$table_name} DRC Total Run time #{run_time} seconds")
